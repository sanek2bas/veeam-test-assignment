Решение задачи: один поток читает файл блоками и кладет их в буфер, n-потоков берут из этого буфера данные сжимают/разжимают и перекладывают во второй буфер, из которого также один поток записывает в выходной файл. Таким образом получается некая реализация паттерна Producer/Consumer. При этом не должна теряться последовательность блоков данных, для этого каждый блок имеет серийный номер (класс ByteBlock свойство SerialNumber). I/O операции достаточно медленные и нет особого смысла их распаралелливать. Сам буфер представляет собой потокобезопасную очередь (класс SafeThreadQueue), в котором используется объект синхронизации, сочетающий в себе Interlocked и AutoResetEvent. 

Имена исходного и результирующего файлов задаются полностью, включая расширение файла. Для сжатого файла следует указывать формат ".gz"